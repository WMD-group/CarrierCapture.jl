var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"A typical usage will consist of about three steps; 1. preparation, 2. building Potential, and 3. computing capture coefficient. Find more detail for step 2 and step 3 in example notebooks. The command line interface is depreciated and not recommended.","category":"section"},{"location":"usage/#1.-Preparation","page":"Usage","title":"1. Preparation","text":"Before CarrierCapture, you need to calculate potential energy surfaces of atomic vibrations (one-dimensional Configuration Coordinate diagram; 1D-CC) and e-ph coupling matrix element (W_if). Prepare a sequence of structures with displacements which interpolate between two defect states. Run single-point energy calculations on these structures, and extract the total energies. Scripts for preprocessing can be found in /script which require the pymatgen python library.\n\nGenerate 1D-CC\nCalculate equilibrium geometries and total energies of defective supercells with charge states q(initial) and q¬±1(final) denoted Conf.(q) and Conf.(q¬±1), respectively.\nGenerate interpolated and extrapolated structures between Conf.(q) (POSCAR_i) and Conf.(q¬±1) (POSCAR_f). You may use gen_cc_struct.py:\n$ gen_cc_struct.py -i POSCAR_i -f POSCAR_f -d -1 -0.6 -0.4 -0.2 -0.1 0 0.1 0.2 0.4 0.6 1.0\n$ ls\ndisp_dir_i\ndisp_dir_f\nRun total-energy calculations for each structure. Example of the directory tree (template) contains all input files for DFT calculations. Make sure DFT-program writes wavefunctions (e.g. LWAVE=.TRUE. in VASP) for the next stage W_if):\n‚îú‚îÄ‚îÄ 00_q2q¬±1\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 00_q\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DISP_000\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DISP_001\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ...\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ disp_dir -> ../../90_DISPLACEMENT/disp_dir_i\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ template\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 01_q¬±1\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ DISP_000\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ DISP_001\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ ...\n‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ disp_dir -> ../../90_DISPLACEMENT/disp_dir_f\n‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ template\n‚îú‚îÄ‚îÄ 90_DISPLACEMENT\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ disp_dir_f\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ POSCAR_000\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ...\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ disp_dir_i\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ POSCAR_000\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ...\nYou can submit jobs for all calculations using a following script in a high-performance computer with a batch system.\n#!/bin/bash -l\n\nfor NUM in {-14,-13,-12,-11,-10,-09,-08,-07,-06,-05,-04,-03,-02,-01,000,001,002,003,004,005,006,007,008,009,010,011,012,013,014}\ndo\n   #if [ ! -d DISP_$NUM ]\n   #then\n     echo DISP_$NUM\n     cp -r template DISP_$NUM\n     cp disp_dir/POSCAR_$NUM DISP_$NUM/POSCAR\n     cd  DISP_$NUM\n     qsub run.pbs\n     cd ../\n   #fi\ndone\nCalculate ùõ•Q using get_del_Q.py. Generate notential.csv using following script.<a name=\"qe_data\"></a>\n#!/bin/bash -l\n\necho Q, E\nfor NUM in {-14,-13,-12,-11,-10,-09,-08,-07,-06,-05,-04,-03,-02,-01,000,001,002,003,004,005,006,007,008,009,010,011,012,013,014}\ndo\n   en=`tail -n 1 DISP_$NUM/OSZICAR|awk '{print $3};'|sed  's/-./-0./' `\n   del_Q=`get_del_Q.py -i $1 -f  DISP_$NUM/POSCAR`\n   echo ${del_Q}, ${en}\ndone\nExample potential.csv file:\nQ, E\n5.034147844442521, -0.28566871E+03\n4.027331082104984, -0.28581530E+03\n...\n1.0068515567113572, -0.28581699E+03\n0.0, -0.28566641E+03\n\nCalcuate e-ph coupling matrix element W_if <a name=\"wif\"></a>\nYou already have eigenvalues, wavefunctions and configurations. Read Work by Alkauskas and coworkers carefully.\nFind initial and final eigenvalues (œµ_i and œµ_f).\nCalculate overlap initial and final wavefunctions. For VASP, you can use get_wf.py:\n$ python get_wf.py   -d 288 -b 291  -D DISP_000 -i DISP_-02 DISP_-01 DISP_001 DISP_002\n\nGRID ENCUT 918.2911873931497\nfinished making projector list\n--------------\nran get_projector_list in 0.033210 seconds\n---------------\nSTARTING PROJSETUP\nstarted setup_proj\ncalculating projector_values\nonto_projector calcs\nDone\n--------------\n\n...\n\n=================================\n----------- Overlaps ------------\n=================================\n[[0.0574]\n [0.0267]\n [0.0345]\n [0.0643]]\nCalculate the rate of change in overlap between initial and final wavefunctions <œà_i0|œà_f(ùõ•Q)> as the geometry changes ùõ•Q: W_if = (œµ_f - œµ_i) d<œà_i0|œà_f(ùõ•Q)> / dùõ•Q. See more detail in this example.","category":"section"},{"location":"usage/#2.-Building-Potential","page":"Usage","title":"2. Building Potential","text":"See Example.\n\nUse fit_pot! to find a best fit to the data of Q and E. \nUse solve_pot! to solve 1D Shr√∂dinger equation for the potential energy surface (PES).","category":"section"},{"location":"usage/#3.-Computing-Capture-Rates","page":"Usage","title":"3. Computing Capture Rates","text":"See Example.\n\nUse calc_overlap! to calculate the overlap between phonon wave functions.\nUse calc_capt_coeff! to calculate the capture coefficient as a function of temperature.","category":"section"},{"location":"usage/#High-throughput-Usage","page":"Usage","title":"High-throughput Usage","text":"High-throughput usage is possible by preparing files in a similar method to the examples, useParamScan_Harmonic.jl and useParamScan_Anharmonic.jl. It is recommended that a high-performance computer rather than a personal machine is used, depending on how many calculations are performed. The code can then be run remotely using nohup julia useParamScan_Harmonic &.\n\nThe steps are as follows,\n\nDefine the parameters for which capture coefficient C will be calculated.\nCalculate C for these parameters, in parallel over the largest parameter range (usually ŒîQ)\nFind ccArray.npz to analyse the capture coefficient as a function of its parameters.","category":"section"},{"location":"lib/brooglie/#Public-Documentation","page":"Brooglie","title":"Public Documentation","text":"Documentation for the submodule Brooglie.jl.\n\nThis module is a solver for the time-independent Schr√∂dinger equation and a copy of a project https://github.com/RedPointyJackson/Brooglie (MIT License).","category":"section"},{"location":"lib/brooglie/#Index","page":"Brooglie","title":"Index","text":"Pages = [\"brooglie.md\"]","category":"section"},{"location":"lib/brooglie/#Public-Interface","page":"Brooglie","title":"Public Interface","text":"","category":"section"},{"location":"lib/brooglie/#CarrierCapture.Brooglie","page":"Brooglie","title":"CarrierCapture.Brooglie","text":"A copy of https://github.com/RedPointyJackson/Brooglie\n\n\n\n\n\n","category":"module"},{"location":"lib/brooglie/#CarrierCapture.Brooglie.buildH-Tuple{Any}","page":"Brooglie","title":"CarrierCapture.Brooglie.buildH","text":"buildH(V; N=20, a=-1, b=1, m=1)\n\nHamiltonian of a particle of mass m in a box spanning from a to b in all D dimensions with a basis of N elements (number of partitions of the space in each coordinate). The potential V(x, y, z, ...) is a function of D arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/brooglie/#CarrierCapture.Brooglie.solve-Tuple{Any}","page":"Brooglie","title":"CarrierCapture.Brooglie.solve","text":"solve(V; N=500, a=-1, b=1, m=1, nev=N√∑20, maxiter=1000)\n\nSolve the potential V(x,y,z,...) in a grid x·µ¢ ‚àà [a,b], discretized in N steps.\n\nThe particle is assumed to have mass m (by default 1, a electron mass).\n\nThe function will return the nev first energy levels (in Hartree[1]) and its normalized eigenfunctions.\n\n[1] A Hartree is equivalent to 27.21‚Ä¶ eV. The global variable H2eV, equal to that value, can be accessed under Brooglie.H2eV for convenience.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"Documentation for CarrierCapture.jl's public interface.","category":"section"},{"location":"lib/public/#Contents","page":"Public","title":"Contents","text":"Pages = [\"public.md\"]","category":"section"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"Pages = [\"public.md\"]","category":"section"},{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/#CarrierCapture","page":"Public","title":"CarrierCapture","text":"Main module for CarrierCapture.jl ‚Äì A set of codes to compute carrier capture and recombination rates in semiconducting compounds.\n\nTwo structs are exported from this module for public use:\n\nPotential: Potential.\nconf_coord: Configuration coordinate.\nPlotter: Auxiliary submodule for plotting.\nBrooglie: 1D Shr√∂dinger equation solver.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CarrierCapture.Potential","page":"Public","title":"CarrierCapture.Potential","text":"Stores a potential in one-dimensional space Q, with discreet points (E0, Q0) and fitting function func.\n\nFields\n\nname ‚Äì the name of Potential.\nQE_data   ‚Äì the (n X 2) DataFrame of data points (Q vs Energy).\nE0, Q0  ‚Äì the minimum point of the Potential [Q0, E0].\nfunc_type     ‚Äì the type of fitting function (\"bspline\", \"spline\", \"harmonic\", \"polyfunc\", \"morse_poly\", \"morse\").\nparams    ‚Äì the list of hyper parameters for the fitting function.\nQ, E  ‚Äì Q and E=func(Q, p_opt; params). They are not the same as QE_data, they are the data points of the fitted function.\nnev  ‚Äì the number of eigenvalues to be evaluated.\nœµ ‚Äì the list of eigenvalues\nT ‚Äì temperature (only used for filtering sample points)\nT_weight ‚Äì turn on temperature-dependent Boltzman weighting\n\nConstructor\n\nPotential()\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CarrierCapture.fit_pot!","page":"Public","title":"CarrierCapture.fit_pot!","text":"fit_pot!(pot::Potential)\n\nFit a function pot.func_type to pot.QE_data on the domain pot.Q.\n\nparameters\n\npot: Potential\npot.func_type: the fitting function; {\"spline\" (preferred), \"bspline\", \"harmonic\", \"polyfunc\", \"morse_poly\", \"morse\"}.\npot.params: the hyperparameters.\n\nHyperparameters params\n\nspline (preferred)\nSpline interpolation. See more detail in Dierckx.jl.\norder: spline order (between 1 and 5; default 2).\nsmoothness: the amount of smoothness is determined by the condition that sum((w[i]*(y[i]-spline(x[i])))**2) <= s\nweight: the weight applied to each QE_data point (length m 1-d array).\n\nbspline\nBasic spline interpolation. See more detail in Interpolations.jl.\n\nharmonic\nHarmonic function whose minimum is at [pot.Q0, pot.E0].\nhw: the energy quanta of the harmonic oscillator.\n\npolyfunc\nPolynomial function;       y = E‚ÇÄ + Œ£ coeffs[i].* (x .- Q‚ÇÄ) .^(i-1).\npoly_order: the maximum order of polynomials.\np0: the initial parameters for the fitting function.\n\nmorse\nMorse potential function centered at [pot.Q0, pot.E0].\np0: initial parameters [A, a] for the Morse potential (default: zeros(2)).\n\nmorse_poly\nMorse potential with polynomial corrections.\npoly_order: the order(s) of polynomial corrections (Int or String of space-separated integers).\np0: initial parameters for fitting (default: zeros(poly_order)).\n\nExample\n\nSpline fit\n\nnev = 60\nname = \"DX-+h\"\n\nQ1 = [30.66721918 29.860133 29.05306268 28.24612992 27.43911044 26.63197583 25.82507425 25.01797262 24.21096115 23.40387798 22.59690043 21.78991117 20.98281579 20.17570172 19.36884219 18.56169249 17.75463179 16.94772679 16.14061031 15.33347439 14.52663309 13.71945696 12.91240658 12.10544441 11.29841968 10.4913338 9.684370388 8.877289725 8.070184138]\nE1 = [8.0902 7.5970 7.0749 6.5242 5.9461 5.3451 4.7300 4.1147 3.5182 2.9637 2.4769 2.0819 1.7972 1.6315 1.5800 1.6237 1.7301 1.8586 1.9687 2.0283 2.0190 2.0673 1.9910 2.0528 1.9730 2.0857 2.4550 3.1653 4.3448]\n\npot = Potential(); pot.name = name\npot.nev = nev\npot.Q0 = Q1[findmin(E1)[2]]; pot.E0 = 1.69834\npot.QE_data = DataFrame(Q = Q1[:], E = E1[:])\npot.QE_data.E .+= - minimum(pot.QE_data.E) + pot.E0\npot.Q = Q\n\npot.func_type = \"spline\"\n# spline fitting parameters\nparams = Dict()\nparams[\"order\"] = 4\nparams[\"smoothness\"] = 0.001\nparams[\"weight\"] = [1 1 1 1 1 0.5 0.4 0.4 0.5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]\nfit_pot!(pot)\n\nHarmonic\n\nnev = 40\nname = \"SnIII+h\"\n\npot = Potential(); pot.name = name\npot.Q0 = 1.90291674728; pot.E0 = 0.585005\npot.nev = nev\npot.func_type = \"harmonic\"\nparams = Dict()\nparams[\"hw\"] = 0.0281812646475\nfit_pot!(pot)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CarrierCapture.filter_sample_points!","page":"Public","title":"CarrierCapture.filter_sample_points!","text":"filter_sample_points!(pot::Potential, thermal_energy::Float64)\n\nRemove data points that are thermally inaccessible from the potential minimum. Keeps only the contiguous region of points below thermal_energy + pot.E0 that contains the minimum energy point.\n\nArguments\n\npot::Potential: The potential to filter (modified in place).\nthermal_energy::Float64: The thermal energy threshold in eV.\n\nNotes\n\nThis function assumes the potential has a single minimum. Throws ArgumentError if multiple minima are found.\n\n\n\n\n\nfilter_sample_points!(pot::Potential)\n\nFilter data points using the temperature pot.T to compute thermal energy (pot.T * boltz). See filter_sample_points!(pot, thermal_energy) for details.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CarrierCapture.solve_pot!","page":"Public","title":"CarrierCapture.solve_pot!","text":"solve_pot!(pot::Potential)\n\nSolve 1D Shr√∂dinger equation for Potential. pot.œµ and pot.œá store the eigenvalues and eigenvectors, respectively.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CarrierCapture.find_crossing","page":"Public","title":"CarrierCapture.find_crossing","text":"find_crossing(pot_1::Potential, pot_2::Potential)\n\nFind the crossing point between two potential energy surfaces pot1 and pot2. Qx, Ex = find_crossing(pot1, pot2).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CarrierCapture.conf_coord","page":"Public","title":"CarrierCapture.conf_coord","text":"Stores two Potentials with e-ph coupling constant W to calculate the capture coefficient capt_coeff(temperature).\n\nFields\n\nname ‚Äì the name of a configuration coordinate.\nV1 and V2 ‚Äì the initial and final Potentials.\nW ‚Äì the e-ph coupling matrix element.\ng ‚Äì the degeneracy.\ntemperature ‚Äì the temperature range where capt_coeff is calculated.\ncapt_coeff ‚Äì the capture coefficient.\n\nConstructor\n\nconf_coord(pot_i::Potential, pot_f::Potential)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CarrierCapture.calc_overlap!","page":"Public","title":"CarrierCapture.calc_overlap!","text":"calc_overlap!(cc::conf_coord; cut_off = 0.25, œÉ = 0.025, Q‚ÇÄ)\n\nCalculate phonon overlap between phonon wave functions 'Potential.œá'. If energy difference is larger then the cutoff (eV) abs(cc.V1.œµ[i] - cc.V2.œµ[j]) > cut_off, the overlap will not be calculated. Delta functions are replaced by Gaussian functions with widths œÉ. Q‚ÇÄ should be consistent with the middle datapoint used to calculate the e-ph coupling matrix element W.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CarrierCapture.calc_capt_coeff!","page":"Public","title":"CarrierCapture.calc_capt_coeff!","text":"calc_capt_coeff!(cc::conf_coord, V::Float64, temperature)\n\nCalculate the capture coefficient cc.capt_coeff as a function of temperature which is a UnitRange. V is a volume where the electron-phonon coupling matrix element cc.W is calculated. The lowest thermal occupation number of the eigenstate must be lower than occ_cut_off = 1E-5.\n\n@assert occ_high < occ_cut_off \"occ(œµ_max, T_max): $occ_high should be less than 1.0e-5\"\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"(Image: Logo)\n\nA set of codes to compute carrier capture and recombination rates in semiconducting compounds. This topic has a rich history starting from the work by Huang and Rhys. Our implementation was inspired by the approach (and FORTRAN code) employed by Alkauskas and coworkers, but has been adapted to also describe anharmonic potential energy surfaces.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The codes are written in Julia, while the scripts and Jupyter Notebooks also contain Python and use pymatgen and pawpyseed (tested on Scientific Linux 7 and Linux Mint 18), which are assumed to be installed. The Brooglie package is used to solve the time-independent Schr√∂dinger equation.\n\nInstall the package by:\n\njulia> using Pkg\n\njulia> Pkg.add(PackageSpec(url=\"https://github.com/WMD-group/CarrierCapture.jl.git\"))\n\nTo run the unit tests for the package, use the Pkg.test function. \n\njulia> Pkg.test(\"CarrierCapture\")","category":"section"},{"location":"#Development","page":"Home","title":"Development","text":"The project is hosted on Github. Please use the issue tracker for feature requests, bug reports and more general questions. If you would like to contribute, please do so via a pull request.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"A typical workflow consists of several steps, implemented in a series of programs, which may be run from the command line. Input for the calculations is provided in input.yaml.\n\nPrepare a sequence of atomic structure models with displacements that interpolate between two defect configurations (e.g. a site vacancy in charge states q=0 and q=+1). Run single-point energy calculations on these structures, and extract the total energies. Scripts for preprocessing may be found in script.\nFind a best fit for the energy calculations of the deformed structures (potential) to generate potential energy surfaces (PES). Solve the 1D Schr√∂dinger equation for each PES to obtain their phonon (nuclear) wavefunctions.\nConstruct configuration coordinate (conf_coord) to calculate the wavefunction overlap between each PES,  which forms part of the temperature-dependent capture coefficient.\n\n(Image: schematics)\n\nThe command-line interface (GetPotential.jl and GetRate.jl) is depreciated. Use Jupyter Notebook examples as a template.\n\nUser warning: The values produced by this type of analysis procedure are sensitive to the quality of the input.  We expect that most input data will have been generated by DFT where the basis set, k-points, and ionic forces have been carefully converged. In addition, the alignment of energy surfaces for defects in different charge states requires appropriate finite-size corrections (e.g. see Freysoldt and coworkers and consider using the doped package).","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"The following examples are provided to illustrate some of the applications of these codes. The input data has been generated from density functional theory (DFT) using VASP, but the framework can easily be adapted to accept output from other electronic structure calculators. \n\nSn-on-Zn in Cu2ZnSnS4: Harmonic approximation\nDX-center in GaAs: Anharmonic fitting\nElectron-phonon coupling: Electron-phonon coupling matrix element","category":"section"},{"location":"#Theory","page":"Home","title":"Theory","text":"The electronic matrix element frequently causes feelings of discomfort (Stoneham, 1981)\n\nThe capture of electrons or holes by point defects in a crystalline materials requires the consideration of a number of factors including the coupling between electronic and vibrational degrees of freedom. Many theories and approximations have been developed to describe the reaction kinetics.\n\nThe capture coefficient between an initial and final state for this computational set up is given by (eq. 22 in Alkauskas and coworkers):\n\nC_p = V frac2pihbar g W_if^2 sum_m w_m sum_n langle xi_im Q - Q_0  xi_fnrangle^2 delta (Delta E + mhbarOmega_i -nhbarOmega_f )\n\nHere, V is the volume of the supercell, W<sub>if</sub> is the electron-phonon overlap and Œæ<sub>im</sub> and Œæ<sub>fn</sub> describe the wavefunctions of the m<sup>th</sup> and n<sup>th</sup> phonons in the initial i and final f states. The final delta-function term serves to conserve energy and in practice is replaced by a smearing Gaussian of finite width œÉ.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"@article{kim2020carriercapture,\n  title={Carriercapture. jl: Anharmonic carrier capture},\n  author={Kim, Sunghyun and Hood, Samantha N and van Gerwen, Puck and Whalley, Lucy D and Walsh, Aron},\n  journal={Journal of Open Source Software},\n  volume={5},\n  number={47},\n  pages={2102},\n  year={2020},\n  doi={10.21105/joss.02102},\n  url={https://joss.theoj.org/papers/10.21105/joss.02102},\n}","category":"section"},{"location":"#Extended-Reading-List","page":"Home","title":"Extended Reading List","text":"","category":"section"},{"location":"#Theory-Development","page":"Home","title":"Theory Development","text":"Henry and Lang, Nonradiative capture and recombination by multiphonon emission in GaAs and GaP (1977)\n\nSeminal contribution that introduces many important concepts\n\nHuang, Adiabatic approximation theory and static coupling theory of nonradiative transition (1981)\n\nContext for the static approximation that we employ\n\nStoneham, Non-radiative transitions in semiconductors (1981)\n\nReview on theory and various models of recombination\n\nMarkvart, Determination of potential surfaces from multiphonon transition rates (1981)\n\nDiscussion and treatment of anharmonicity\n\nMarkvart, Semiclassical theory of non-radiative transitions (1981)\n\nSemiclassical treatment of matrix elements following Landau and Holstein","category":"section"},{"location":"#Applications-of-CarrierCapture","page":"Home","title":"Applications of CarrierCapture","text":"Kavanagh et al, Intrinsic point defect tolerance in selenium for indoor and tandem photovoltaics (2025)\nL√≥pez et al, Chalcogen Vacancies Rule Charge Recombination in Pnictogen Chalcohalide Solar-Cell Absorbers (2025)\nWang et al, Sulfur Vacancies Limit the Open-Circuit Voltage of Sb‚ÇÇS‚ÇÉ Solar Cells (2024)\nWang et al, Upper efficiency limit of Sb‚ÇÇS‚ÇÉ solar cells (2024)\nKavanagh et al, Impact of metastable defect structures on carrier recombination in solar cells (2022)\nKavanagh et al, Rapid recombination by cadmium vacancies in CdTe (2021)\nWhalley et al, Giant Huang‚ÄìRhys factor for electron capture by the iodine intersitial in perovskite solar cells (2021)\nKim and Walsh, Ab initio calculation of the detailed balance limit to the photovoltaic efficiency of single p-n junction kesterite solar cells (2021) \nDahliah et al, High-throughput computational search for high carrier lifetime, defect-tolerant solar absorbers (2021)\nKim et al, Upper limit to the photovoltaic efficiency of imperfect crystals (2020) \nKim et al, Anharmonic lattice relaxation during non-radiative carrier capture (2019) \nKim et al, Lone-pair effect on carrier capture in Cu2ZnSnS4 solar cells (2019)\nKim et al, Identification of killer defects in kesterite thin-film solar cells (2018)","category":"section"},{"location":"lib/plotter/#Public-Documentation","page":"Plotter","title":"Public Documentation","text":"Documentation for the submodule Plotter.jl.","category":"section"},{"location":"lib/plotter/#Index","page":"Plotter","title":"Index","text":"Pages = [\"plotter.md\"]","category":"section"},{"location":"lib/plotter/#Public-Interface","page":"Plotter","title":"Public Interface","text":"","category":"section"},{"location":"lib/plotter/#CarrierCapture.Plotter","page":"Plotter","title":"CarrierCapture.Plotter","text":"Submodule providing helper functions for generating plots.\n\n\n\n\n\n","category":"module"},{"location":"lib/plotter/#CarrierCapture.Plotter.plot_cc!-Tuple{conf_coord}","page":"Plotter","title":"CarrierCapture.Plotter.plot_cc!","text":"plot_cc!(cc; plt = nothing, color = nothing, label = \"\")\n\nPlots capture coefficient cc.capt_coeff as a function of 1000/T.\n\n\n\n\n\n","category":"method"},{"location":"lib/plotter/#CarrierCapture.Plotter.plot_pot!-Tuple{Potential}","page":"Plotter","title":"CarrierCapture.Plotter.plot_pot!","text":"plot_pot!(pot; lplt_wf = false, plt = nothing, color = Nothing, label = \"\", scale_factor = 2e-2)\n\nPlots Potential with its' wave functions if lplt_wf is true.\n\n\n\n\n\n","category":"method"}]
}
